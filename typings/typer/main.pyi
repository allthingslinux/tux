"""
This type stub file was generated by pyright.
"""

import click
from enum import Enum
from pathlib import Path
from types import TracebackType
from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Type, Union
from .core import MarkupMode, TyperCommand, TyperGroup
from .models import AnyType, CommandFunctionType, CommandInfo, ParamMeta, ParameterInfo, TyperInfo

_original_except_hook = ...
_typer_developer_exception_attr_name = ...
def except_hook(exc_type: Type[BaseException], exc_value: BaseException, tb: Optional[TracebackType]) -> None:
    ...

def get_install_completion_arguments() -> Tuple[click.Parameter, click.Parameter]:
    ...

class Typer:
    def __init__(self, *, name: Optional[str] = ..., cls: Optional[Type[TyperGroup]] = ..., invoke_without_command: bool = ..., no_args_is_help: bool = ..., subcommand_metavar: Optional[str] = ..., chain: bool = ..., result_callback: Optional[Callable[..., Any]] = ..., context_settings: Optional[Dict[Any, Any]] = ..., callback: Optional[Callable[..., Any]] = ..., help: Optional[str] = ..., epilog: Optional[str] = ..., short_help: Optional[str] = ..., options_metavar: str = ..., add_help_option: bool = ..., hidden: bool = ..., deprecated: bool = ..., add_completion: bool = ..., rich_markup_mode: MarkupMode = ..., rich_help_panel: Union[str, None] = ..., pretty_exceptions_enable: bool = ..., pretty_exceptions_show_locals: bool = ..., pretty_exceptions_short: bool = ...) -> None:
        ...
    
    def callback(self, *, cls: Optional[Type[TyperGroup]] = ..., invoke_without_command: bool = ..., no_args_is_help: bool = ..., subcommand_metavar: Optional[str] = ..., chain: bool = ..., result_callback: Optional[Callable[..., Any]] = ..., context_settings: Optional[Dict[Any, Any]] = ..., help: Optional[str] = ..., epilog: Optional[str] = ..., short_help: Optional[str] = ..., options_metavar: str = ..., add_help_option: bool = ..., hidden: bool = ..., deprecated: bool = ..., rich_help_panel: Union[str, None] = ...) -> Callable[[CommandFunctionType], CommandFunctionType]:
        ...
    
    def command(self, name: Optional[str] = ..., *, cls: Optional[Type[TyperCommand]] = ..., context_settings: Optional[Dict[Any, Any]] = ..., help: Optional[str] = ..., epilog: Optional[str] = ..., short_help: Optional[str] = ..., options_metavar: str = ..., add_help_option: bool = ..., no_args_is_help: bool = ..., hidden: bool = ..., deprecated: bool = ..., rich_help_panel: Union[str, None] = ...) -> Callable[[CommandFunctionType], CommandFunctionType]:
        ...
    
    def add_typer(self, typer_instance: Typer, *, name: Optional[str] = ..., cls: Optional[Type[TyperGroup]] = ..., invoke_without_command: bool = ..., no_args_is_help: bool = ..., subcommand_metavar: Optional[str] = ..., chain: bool = ..., result_callback: Optional[Callable[..., Any]] = ..., context_settings: Optional[Dict[Any, Any]] = ..., callback: Optional[Callable[..., Any]] = ..., help: Optional[str] = ..., epilog: Optional[str] = ..., short_help: Optional[str] = ..., options_metavar: str = ..., add_help_option: bool = ..., hidden: bool = ..., deprecated: bool = ..., rich_help_panel: Union[str, None] = ...) -> None:
        ...
    
    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        ...
    


def get_group(typer_instance: Typer) -> TyperGroup:
    ...

def get_command(typer_instance: Typer) -> click.Command:
    ...

def solve_typer_info_help(typer_info: TyperInfo) -> str:
    ...

def solve_typer_info_defaults(typer_info: TyperInfo) -> TyperInfo:
    ...

def get_group_from_info(group_info: TyperInfo, *, pretty_exceptions_short: bool, rich_markup_mode: MarkupMode) -> TyperGroup:
    ...

def get_command_name(name: str) -> str:
    ...

def get_params_convertors_ctx_param_name_from_function(callback: Optional[Callable[..., Any]]) -> Tuple[List[Union[click.Argument, click.Option]], Dict[str, Any], Optional[str]]:
    ...

def get_command_from_info(command_info: CommandInfo, *, pretty_exceptions_short: bool, rich_markup_mode: MarkupMode) -> click.Command:
    ...

def determine_type_convertor(type_: Any) -> Optional[Callable[[Any], Any]]:
    ...

def param_path_convertor(value: Optional[str] = ...) -> Optional[Path]:
    ...

def generate_enum_convertor(enum: Type[Enum]) -> Callable[[Any], Any]:
    ...

def generate_list_convertor(convertor: Optional[Callable[[Any], Any]], default_value: Optional[Any]) -> Callable[[Sequence[Any]], Optional[List[Any]]]:
    ...

def generate_tuple_convertor(types: Sequence[Any]) -> Callable[[Optional[Tuple[Any, ...]]], Optional[Tuple[Any, ...]]]:
    ...

def get_callback(*, callback: Optional[Callable[..., Any]] = ..., params: Sequence[click.Parameter] = ..., convertors: Optional[Dict[str, Callable[[str], Any]]] = ..., context_param_name: Optional[str] = ..., pretty_exceptions_short: bool) -> Optional[Callable[..., Any]]:
    ...

def get_click_type(*, annotation: Any, parameter_info: ParameterInfo) -> click.ParamType:
    ...

def lenient_issubclass(cls: Any, class_or_tuple: Union[AnyType, Tuple[AnyType, ...]]) -> bool:
    ...

def get_click_param(param: ParamMeta) -> Tuple[Union[click.Argument, click.Option], Any]:
    ...

def get_param_callback(*, callback: Optional[Callable[..., Any]] = ..., convertor: Optional[Callable[..., Any]] = ...) -> Optional[Callable[..., Any]]:
    ...

def get_param_completion(callback: Optional[Callable[..., Any]] = ...) -> Optional[Callable[..., Any]]:
    ...

def run(function: Callable[..., Any]) -> None:
    ...

def launch(url: str, wait: bool = ..., locate: bool = ...) -> int:
    """This function launches the given URL (or filename) in the default
    viewer application for this file type.  If this is an executable, it
    might launch the executable in a new session.  The return value is
    the exit code of the launched application.  Usually, ``0`` indicates
    success.

    This function handles url in different operating systems separately:
    - On macOS (Darwin), it uses the 'open' command.
    - On Linux and BSD, it uses 'xdg-open' if available.
    - On Windows (and other OSes), it uses the standard webbrowser module.

    The function avoids, when possible, using the webbrowser module on Linux and macOS
    to prevent spammy terminal messages from some browsers (e.g., Chrome).

    Examples::

        typer.launch("https://typer.tiangolo.com/")
        typer.launch("/my/downloaded/file", locate=True)

    :param url: URL or filename of the thing to launch.
    :param wait: Wait for the program to exit before returning. This
        only works if the launched program blocks. In particular,
        ``xdg-open`` on Linux does not block.
    :param locate: if this is set to `True` then instead of launching the
                   application associated with the URL it will attempt to
                   launch a file manager with the file located.  This
                   might have weird effects if the URL does not point to
                   the filesystem.
    """
    ...

