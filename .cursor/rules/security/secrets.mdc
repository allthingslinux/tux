---
description: Secret management, environment variables, credential handling, and secure configuration for Tux
globs: src/tux/**/*.py, .env*, config/*.toml, config/*.yaml, config/*.json
alwaysApply: false
---

# Secret Management

## Overview

Tux uses environment variables and Pydantic Settings for secure secret management. Secrets are never hard-coded and are loaded from environment variables with proper validation.

## Environment Variables

### Configuration Priority

Secrets are loaded in priority order:

1. **Environment variables** (highest priority)
2. `.env` file
3. `config.toml` file
4. `config.yaml` file
5. `config.json` file
6. Default values (lowest priority)

✅ **GOOD:** Environment variables override file config

### Using Environment Variables

```python
from tux.shared.config import CONFIG

# ✅ GOOD: Access secrets via CONFIG
bot_token = CONFIG.BOT_TOKEN
database_url = CONFIG.database_url
```

❌ **BAD:** Hard-coding secrets or using os.getenv directly

```python
# ❌ BAD: Hard-coded secret
BOT_TOKEN = "hard-coded-token-here"

# ❌ BAD: Direct os.getenv (use CONFIG instead)
token = os.getenv("BOT_TOKEN")
```

## Secret Validation

### Password Validation

Tux validates database passwords on startup:

```python
# ✅ GOOD: Validation prevents weak passwords
def validate_environment() -> None:
    db_password = os.getenv("POSTGRES_PASSWORD", "")
    weak_passwords = ["password", "admin", "postgres", "123456"]

    if db_password in weak_passwords:
        raise ValueError("Cannot use insecure password!")
```

✅ **GOOD:** Validation prevents insecure defaults

### Secret Strength

```python
# ✅ GOOD: Enforce minimum password length
if len(db_password) < 12:
    warnings.warn("Password too short (<12 chars)")
```

## Secret Sanitization

### Logging Secrets

```python
from tux.services.sentry.handlers import _sanitize_sensitive_data

# ✅ GOOD: Sanitize before logging
log_message = _sanitize_sensitive_data(f"URL: {database_url}")
logger.info(log_message)
# Output: "URL: postgresql://***:***@host:port/db"
```

❌ **BAD:** Logging secrets directly

```python
# ❌ BAD: Logging secrets
logger.info(f"Database URL: {database_url}")  # Contains password!
```

### Sentry Sanitization

Sentry automatically sanitizes sensitive data:

```python
# ✅ GOOD: Sentry sanitizes automatically
from tux.services.sentry.handlers import _sanitize_event_data

# Event data is sanitized before sending to Sentry
```

## Configuration Files

### .env File

```bash
# ✅ GOOD: .env file for local development
BOT_TOKEN=your-token-here
POSTGRES_PASSWORD=strong-password-here
```

✅ **GOOD:** .env file is gitignored

### Config Files

```toml
# ✅ GOOD: Config files for non-sensitive defaults
# config.toml (example, not committed)
[bot]
token = ""  # Empty default, use environment variable
```

❌ **BAD:** Committing secrets to config files

```toml
# ❌ BAD: Secrets in committed files
[bot]
token = "actual-secret-token"  # Never commit this!
```

## Best Practices

1. **Use environment variables** - For all secrets
2. **Access via CONFIG** - Use CONFIG object, not os.getenv
3. **Validate secrets** - Check password strength, etc.
4. **Sanitize before logging** - Never log secrets
5. **Gitignore .env** - Never commit .env files
6. **Empty defaults** - Use empty strings for secrets in config files
7. **Document requirements** - Document required environment variables

## Anti-Patterns

1. ❌ **Hard-coded secrets** - Always use environment variables
2. ❌ **Committing secrets** - Never commit .env or secrets
3. ❌ **Logging secrets** - Sanitize before logging
4. ❌ **Weak passwords** - Enforce password strength
5. ❌ **Direct os.getenv** - Use CONFIG instead
6. ❌ **Secrets in code** - Never hard-code secrets

## See Also

- @security/patterns.mdc - Security patterns
- @security/validation.mdc - Input validation
- @core/tech-stack.mdc - Configuration system
- @AGENTS.md - General coding standards
- @rules.mdc - Complete catalog of all rules and commands
