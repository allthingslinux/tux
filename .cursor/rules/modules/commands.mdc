---
description: Discord command patterns, hybrid commands, slash commands, command decorators, and response patterns for Tux
globs: src/tux/modules/**/*.py
alwaysApply: false
---

# Discord Bot Commands

## Overview

Tux uses discord.py hybrid commands (slash + traditional) with proper decorators, error handling, and permission checks. Commands should be well-typed, documented, and follow Tux patterns.

## Command Types

### Hybrid Commands

Hybrid commands work as both slash and traditional commands:

```python
@commands.hybrid_command(
    name="mycommand",
    aliases=["mc", "cmd"],
    description="Command description for slash command"
)
@commands.guild_only()
@requires_command_permission()
async def my_command(
    self,
    ctx: commands.Context[Tux],
    member: discord.Member,
    reason: str | None = None,
) -> None:
    """Command description (appears in help).

    Parameters
    ----------
    ctx : commands.Context[Tux]
        The command context.
    member : discord.Member
        The member to act on.
    reason : str, optional
        Optional reason for the action.
    """
    assert ctx.guild  # Required for guild_only commands
    # Command implementation
```

✅ **GOOD:** Hybrid command, proper decorators, type hints, docstring

❌ **BAD:** Missing decorators, no type hints

```python
# ❌ BAD: Missing decorators and type hints
@commands.command()
async def my_command(self, ctx, member):
    # Missing guild_only, permissions, type hints
    pass
```

### Traditional Commands

For commands that don't need slash support:

```python
@commands.command(
    name="mycommand",
    aliases=["mc"],
)
@commands.guild_only()
@requires_command_permission()
async def my_command(
    self,
    ctx: commands.Context[Tux],
    member: discord.Member,
) -> None:
    """Command description."""
    # Implementation
```

### Command Groups

For nested commands:

```python
@commands.hybrid_group(
    name="config",
    aliases=["settings"],
)
@commands.guild_only()
@requires_command_permission()
async def config(self, ctx: commands.Context[Tux]) -> None:
    """Manage guild configuration."""
    if ctx.invoked_subcommand is None:
        # Show help or default action
        await self.show_config_overview(ctx)

@config.command(name="set")
@commands.guild_only()
@requires_command_permission()
async def config_set(
    self,
    ctx: commands.Context[Tux],
    key: str,
    value: str,
) -> None:
    """Set a configuration value."""
    # Implementation
```

✅ **GOOD:** Proper group structure, subcommand handling

## Command Decorators

### Required Decorators

```python
# ✅ GOOD: Always include these decorators
@commands.hybrid_command(name="command")
@commands.guild_only()  # If command requires guild
@requires_command_permission()  # Permission check
async def command(self, ctx: commands.Context[Tux]) -> None:
    pass
```

### Guild-Only Commands

```python
# ✅ GOOD: Use guild_only for commands that need a guild
@commands.guild_only()
async def command(self, ctx: commands.Context[Tux]) -> None:
    assert ctx.guild  # Type narrowing after guild_only
    # Safe to use ctx.guild
```

### Permission Checks

```python
# ✅ GOOD: Use permission decorator
from tux.core.decorators import requires_command_permission
# or
from tux.core.checks import requires_command_permission

@requires_command_permission()
async def command(self, ctx: commands.Context[Tux]) -> None:
    # Permission checked automatically
    # Reads required rank from database per-guild
    # Bot owners, sysadmins, and guild owners bypass automatically
    pass
```

❌ **BAD:** Manual permission checks

```python
# ❌ BAD: Don't manually check permissions
async def command(self, ctx: commands.Context[Tux]) -> None:
    if not await check_permission(ctx):
        return  # Use decorator instead!
```

## Command Parameters

### Type Hints

Always use proper type hints:

```python
# ✅ GOOD: Proper type hints
async def command(
    self,
    ctx: commands.Context[Tux],
    member: discord.Member,
    reason: str | None = None,
    count: int = 1,
) -> None:
    pass
```

❌ **BAD:** Missing or incorrect type hints

```python
# ❌ BAD: Missing type hints
async def command(self, ctx, member, reason=None):
    pass
```

### Optional Parameters

```python
# ✅ GOOD: Use | None for optional parameters
async def command(
    self,
    ctx: commands.Context[Tux],
    member: discord.Member,
    reason: str | None = None,  # Optional
) -> None:
    if reason:
        # Handle reason
        pass
```

### Flag Parameters

For complex parameters, use Flag classes:

```python
from tux.core.flags import WarnFlags

@commands.hybrid_command(name="warn")
async def warn(
    self,
    ctx: commands.Context[Tux],
    member: discord.Member,
    *,
    flags: WarnFlags,  # Flags for complex options
) -> None:
    reason = flags.reason
    silent = flags.silent
```

## Command Responses

### Sending Messages

```python
# ✅ GOOD: Use appropriate response method
await ctx.send("Simple message")
await ctx.send(embed=embed)  # With embed
await ctx.send(view=view)  # With view/components
```

### Deferring Responses

For long-running operations:

```python
# ✅ GOOD: Defer for long operations (works for both slash and prefix)
await ctx.defer(ephemeral=True)  # For user-only responses
# or
await ctx.defer()  # For public responses

# Do long operation
result = await long_operation()

# Send result (ctx.defer handles both slash and prefix automatically)
await ctx.send(result)
# or
await ctx.reply(result, ephemeral=True)
```

### Error Responses

```python
# ✅ GOOD: Use error embeds
from tux.ui.embeds import EmbedCreator, EmbedType

embed = EmbedCreator.create_embed(
    embed_type=EmbedType.ERROR,
    title="Error",
    description="Something went wrong"
)
await ctx.send(embed=embed)

# ✅ GOOD: Use ctx.reply() for ephemeral error responses
await ctx.reply(
    content="An error occurred",
    ephemeral=True,
    allowed_mentions=discord.AllowedMentions(users=False, roles=False, everyone=False)
)
```

### Reply Patterns

```python
# ✅ GOOD: Use ctx.reply() for command responses
await ctx.reply(
    content="Response message",
    embed=embed,  # Optional embed
    ephemeral=True,  # User-only response
    allowed_mentions=discord.AllowedMentions(users=False)  # Control mentions
)

# ✅ GOOD: Use ctx.send() for general messages
await ctx.send("Message")
await ctx.send(embed=embed)

# ✅ GOOD: Use ctx.send_help() for command help
await ctx.send_help("command_name")
```

## Slash-Only Commands

For commands that only work as slash commands:

```python
from discord import app_commands

@app_commands.command(name="tldr")
@app_commands.guild_only()
@app_commands.describe(
    command="The command to look up",
    platform="Platform (e.g. linux, osx)",
)
@app_commands.autocomplete(platform=platform_autocomplete)
@app_commands.choices(encoding=[
    app_commands.Choice(name="base16", value="base16"),
    app_commands.Choice(name="base32", value="base32"),
])
async def slash_tldr(
    self,
    interaction: discord.Interaction,
    command: str,
    platform: str | None = None,
) -> None:
    """Show a TLDR page for a CLI command."""
    # Implementation
    pass
```

✅ **GOOD:** Use `@app_commands.command()` for pure slash commands with autocomplete and choices

## Command Error Handling

### Try-Except Blocks

```python
# ✅ GOOD: Handle errors properly
from tux.ui.embeds import EmbedCreator, EmbedType
from loguru import logger

async def command(self, ctx: commands.Context[Tux]) -> None:
    try:
        # Command logic
        pass
    except discord.Forbidden:
        embed = EmbedCreator.create_embed(
            embed_type=EmbedType.ERROR,
            title="Permission Denied",
            description="I don't have permission to do that."
        )
        await ctx.send(embed=embed)
    except Exception as e:
        logger.exception("Command failed")
        # Let global error handler format and send error
        raise  # Global handler will format and send user-friendly error
```

✅ **GOOD:** Let global error handler format errors automatically

### Error Handler Cogs

For global error handling:

```python
@commands.Cog.listener()
async def on_command_error(
    self,
    ctx: commands.Context[Tux],
    error: commands.CommandError,
) -> None:
    # Handle command errors
    pass
```

## Best Practices

1. **Use hybrid commands** - Support both slash and traditional commands
2. **Always type hints** - Type all parameters and return types
3. **Use decorators** - `@commands.guild_only()`, `@requires_command_permission()`
4. **Document commands** - NumPy docstrings with Parameters section
5. **Handle errors** - Let global error handler format errors, or handle specific exceptions
6. **Use embeds** - For rich responses (EmbedCreator.create_embed)
7. **Assert ctx.guild** - After `@commands.guild_only()` decorator for type narrowing
8. **Use ctx.defer()** - For long-running operations (works for both slash and prefix)
9. **Use ctx.reply()** - For command responses with ephemeral support
10. **Use ctx.send_help()** - For showing command help
11. **Control mentions** - Use `allowed_mentions` parameter to prevent unwanted pings
12. **Use flags** - For complex parameters, use FlagConverter classes

## Anti-Patterns

1. ❌ **Missing type hints** - Always type parameters and return types
2. ❌ **Missing decorators** - Use `@commands.guild_only()` and `@requires_command_permission()`
3. ❌ **No error handling** - Let global error handler work, or handle specific exceptions
4. ❌ **Plain text responses** - Use embeds for rich responses (EmbedCreator.create_embed)
5. ❌ **Manual permission checks** - Use `@requires_command_permission()` decorator
6. ❌ **No docstrings** - Document all commands with NumPy docstrings
7. ❌ **Using EmbedCreator.error()** - Use `EmbedCreator.create_embed(embed_type=EmbedType.ERROR)`
8. ❌ **Manual interaction handling** - Use `ctx.defer()` instead of `ctx.interaction.response.defer()`
9. ❌ **Not using ctx.reply()** - Use `ctx.reply()` for command responses
10. ❌ **Uncontrolled mentions** - Always specify `allowed_mentions` to prevent unwanted pings
11. ❌ **Not deferring long operations** - Use `ctx.defer()` for operations that take > 2 seconds
12. ❌ **Missing assert ctx.guild** - Assert after `@commands.guild_only()` for type narrowing

## See Also

- @modules/cogs.mdc - Cog structure
- @modules/permissions.mdc - Permission patterns
- @modules/interactions.mdc - Interaction patterns
- @ui/cv2.mdc - Components V2 patterns
- @AGENTS.md - General coding standards
- @rules.mdc - Complete catalog of all rules and commands
