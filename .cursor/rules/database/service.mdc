---
alwaysApply: true
description: DatabaseService patterns, connection management, and session handling rules
---

# Database Service Rules

The DatabaseService is the foundation layer for PostgreSQL database operations, providing robust connection management, session handling, health monitoring, and error recovery.

## Core Responsibilities

### Connection Lifecycle Management

- Initialize async engine with connection pooling
- Handle connection state (disconnected, connected, error)
- Automatic reconnection with retry logic
- Graceful shutdown and resource cleanup

### Session Factory Pattern

- Create sessions through factory pattern for consistency
- Proper async session configuration
- Automatic transaction handling
- Context manager support for resource safety

### Retry Logic Implementation

- Automatic retry with exponential backoff
- Handle transient database failures
- Docker container startup delays
- Network resilience

## Key Patterns

### Session Context Managers

**Always use context managers for session management:**

```python
async with db.session() as session:
    result = await session.execute(select(User))
    users = result.scalars().all()
    # Automatic commit on success, rollback on exception
```

**Benefits:**

- Automatic resource cleanup
- Proper transaction handling
- Exception safety
- No manual commit/rollback needed

### Connection Pooling Configuration

```python
engine = create_async_engine(
    database_url,
    pool_pre_ping=True,      # Validate connections before use
    pool_recycle=3600,       # Recycle connections after 1 hour
    echo=False,              # SQL query logging (debug only)
)
```

**Configuration Guidelines:**

- Always enable `pool_pre_ping` for connection validation
- Set `pool_recycle` to prevent stale connections
- Use `echo=True` only for debugging (never in production)
- Configure pool size based on workload (default is usually fine)

### Health Checks

**Implement health checks for monitoring:**

```python
health = await db.health_check()
# Returns: {'status': 'healthy', 'mode': 'async'}
# Or: {'status': 'unhealthy', 'error': '...'}
```

**Use Cases:**

- Startup validation
- Periodic health monitoring
- Error recovery detection
- Load balancer health endpoints

### Retry Logic with Exponential Backoff

**Automatic retry for transient failures:**

```python
result = await db.execute_query(
    operation=lambda session: session.execute(query),
    span_desc="fetch_users"
)
```

**Retry Behavior:**

- Max 3 retries by default
- Exponential backoff: 0.5s, 1s, 2s
- Retries on: DisconnectionError, TimeoutError, OperationalError
- Raises exception after all retries exhausted

### Sentry Integration

**Performance monitoring and error tracking:**

- Automatic span creation for database operations
- Error context and attempt tracking
- Status updates for observability
- Query performance metrics

## Usage Patterns

### Basic Session Usage

```python
async with db.session() as session:
    user = User(name="Alice")
    session.add(user)
    # Auto-committed on exit
```

### Transaction Management

```python
async with db.session() as session:
    async with session.begin():
        # Explicit transaction boundary
        await session.execute(update(User).values(name="Bob"))
        # Committed on exit, rolled back on exception
```

### Custom Query Execution

```python
async def fetch_users():
    async with db.session() as session:
        result = await session.execute(
            select(User).where(User.active == True)
        )
        return result.scalars().all()
```

### Health Check Pattern

```python
async def check_database_health():
    health = await db.health_check()
    if health["status"] != "healthy":
        logger.error(f"Database unhealthy: {health.get('error')}")
        # Handle unhealthy state
```

## Best Practices

### Always Use Context Managers

- ✅ Use `async with db.session()` for all operations
- ✅ Never manually manage session lifecycle
- ✅ Let context manager handle commit/rollback

### Connection Management

- ✅ Connect once at startup, reuse service instance
- ✅ Use health checks for validation, not connection testing
- ✅ Let retry logic handle transient failures

### Error Handling

- ✅ Let retry logic handle transient errors automatically
- ✅ Log connection errors with context
- ✅ Raise exceptions for non-retryable errors
- ✅ Use Sentry spans for production monitoring

### Performance Considerations

- ✅ Reuse DatabaseService instance (singleton pattern)
- ✅ Use connection pooling (automatic with async engine)
- ✅ Enable pre-ping for connection validation
- ✅ Set appropriate pool recycle time

### Testing Patterns

- ✅ Mock DatabaseService for unit tests
- ✅ Use real database for integration tests
- ✅ Test retry logic with simulated failures
- ✅ Verify health check behavior

## Anti-Patterns

### ❌ Manual Session Management

```python
# BAD: Manual session management
session = db._session_factory()
try:
    # operations
    await session.commit()
except:
    await session.rollback()
finally:
    await session.close()
```

### ❌ Direct Engine Access

```python
# BAD: Bypassing service layer
engine = db.engine
async with engine.begin() as conn:
    # Direct connection access
```

### ❌ Ignoring Health Checks

```python
# BAD: No health validation
async def startup():
    db.connect(url)  # No validation
    # Start accepting requests
```

### ❌ Disabling Retry Logic

```python
# BAD: Catching and ignoring retryable errors
try:
    result = await operation()
except DisconnectionError:
    # Should let retry logic handle this
    pass
```

## Related Rules

- [`overview.mdc`](overview.mdc) - Architecture overview
- [`controllers.mdc`](controllers.mdc) - Controller layer using service
- [`models.mdc`](models.mdc) - Models used with service
