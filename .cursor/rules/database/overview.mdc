---
alwaysApply: true
description: Database architecture overview and core principles for Tux's three-layer database system
---

# Database Architecture Overview

Tux uses a **three-layer database architecture** that separates concerns while maintaining type safety and developer experience. The architecture prioritizes async-first design, automatic resource management, and composable operations built on PostgreSQL.

## Three-Layer Architecture

### Service Layer

**Foundation layer** handling all PostgreSQL interactions with:

- Connection pooling with retry logic
- Session management with automatic cleanup
- Health monitoring and validation
- Transaction handling with automatic rollback

**Location:** `src/tux/database/service.py`

### Controller Layer

**Business logic layer** providing composable database operations through:

- BaseController with lazy-loaded specialized controllers
- Model-specific controllers (GuildController, CaseController, etc.)
- DatabaseCoordinator facade for centralized access

**Location:** `src/tux/database/controllers/`

### Model Layer

**Type-safe data models** with:

- Automatic timestamp management (created_at, updated_at)
- Relationship definitions with proper cascade behavior
- PostgreSQL-specific type support (JSONB, arrays, enums)
- Serialization utilities for API responses

**Location:** `src/tux/database/models/`

## Core Principles

### Async-First Design

- All database operations are async by default
- Non-blocking I/O for efficient concurrent request handling
- Optimal resource utilization for Discord bot workloads

### Automatic Resource Management

- Sessions and connections managed through context managers
- Proper cleanup and resource leak prevention
- Automatic commit/rollback on success/failure

### Composition Over Inheritance

- Controllers use composition patterns for flexibility
- Lazy-loaded specialized controllers reduce overhead
- Can combine controllers as needed without forcing all functionality

### Transaction Safety

- Transactions automatically managed at session level
- All operations within session context are transactional
- Auto-committed on success, rolled back on failure

### Connection Pooling

- PostgreSQL connections efficiently pooled
- Pre-ping validation and periodic recycling
- Size management optimized for Discord bot workloads

## Layer Interaction Flow

```text
Commands/Interactions
    ↓
DatabaseCoordinator (facade)
    ↓
BaseController (composition)
    ↓
Specialized Controllers (lazy-loaded)
    ↓
DatabaseService (connection management)
    ↓
PostgreSQL
```

## Service Access Patterns

### Bot Attachment

Database services attached directly to bot instances:

```python
bot.db_service  # DatabaseService instance
bot.db  # DatabaseCoordinator instance
```

### Context Resolution

Services automatically discovered from Discord contexts:

```python
from tux.database.utils import get_db_service_from, get_db_controller_from

# From interaction or context
db_service = get_db_service_from(interaction)
coordinator = get_db_controller_from(interaction)
```

### Fallback Support

Graceful degradation when preferred access methods unavailable with logging and migration support.

## When to Use Each Layer

### Controller Layer

- ✅ Standard CRUD operations
- ✅ Business logic with relationships
- ✅ Pagination and filtering
- ✅ Bulk operations
- ✅ Complex queries with joins

### Service Layer

- ✅ Raw SQL queries
- ✅ Performance-critical operations
- ✅ Health checks and monitoring
- ✅ Custom transaction management
- ✅ Direct connection access

### Model Layer

- ✅ Data validation and serialization
- ✅ Relationship definitions
- ✅ Schema definitions
- ✅ Type safety

## Best Practices

### Always Use Controllers for Business Logic

- Never bypass controllers for standard CRUD operations
- Use controllers for type safety and consistency
- Controllers enforce business rules and validation

### Use Service Layer Sparingly

- Only for raw SQL or performance-critical paths
- Health checks and monitoring
- Custom transaction management

### Leverage Model Features

- Use BaseModel for automatic timestamps
- Use mixins (UUIDMixin, SoftDeleteMixin) for common patterns
- Define relationships with proper cascade behavior

### Error Handling Strategy

- **Controller Level**: Business logic errors and validation
- **Service Level**: Connection errors and transaction failures
- **Global Level**: Unexpected errors with monitoring integration

### Testing Strategy

- **Unit Tests**: Test controllers with mocked service layer
- **Integration Tests**: Test full stack with real database
- **Isolation**: Each test uses fresh database schema

## Related Rules

- [`service.mdc`](service.mdc) - DatabaseService patterns and usage
- [`controllers.mdc`](controllers.mdc) - Controller patterns and composition
- [`models.mdc`](models.mdc) - Model definition and best practices
