---
description: DatabaseService patterns, connection management, session handling, and async database operations for Tux
globs: src/tux/database/service.py
alwaysApply: false
---

# Database Service Layer

## Overview

Tux uses `DatabaseService` for async PostgreSQL connection management, session handling, and database operations. The service provides connection pooling, retry logic, and health checks.

## Service Initialization

### Creating Database Service

```python
from tux.database.service import DatabaseService

# ✅ GOOD: Create service instance
db = DatabaseService(echo=False)  # echo=True for SQL logging

# Connect to database
await db.connect(CONFIG.database_url)
```

❌ **BAD:** Creating multiple service instances or not using service

```python
# ❌ BAD: Multiple instances
db1 = DatabaseService()
db2 = DatabaseService()  # Don't create multiple!
```

## Session Management

### Using Sessions

```python
# ✅ GOOD: Use session context manager (auto-connects if needed)
async with db.session() as session:
    # Use session for operations
    result = await session.execute(select(MyModel))
    models = result.scalars().all()
    # Automatically commits on success, rolls back on error
```

**Note:** The `session()` method automatically connects if not already connected using `CONFIG.database_url`.

❌ **BAD:** Manual session creation or not using context manager

```python
# ❌ BAD: Manual session management
session = db._session_factory()
try:
    # operations
finally:
    await session.close()  # Don't do this!
```

### Session in Controllers

Controllers automatically use DatabaseService:

```python
# ✅ GOOD: Controllers use service internally
controller = MyModelController(db)
model = await controller.get(id=123)  # Service manages session

# ❌ BAD: Passing session to controller
async with db.session() as session:
    model = await controller.get(session, id=123)  # Don't do this!
```

## Connection Management

### Connection Pooling

DatabaseService automatically manages connection pooling:

- **pool_pre_ping**: Tests connections before use
- **pool_recycle**: Recycles connections after 1 hour (3600 seconds)
- **expire_on_commit**: False (objects remain accessible after commit)

✅ **GOOD:** Service handles pooling automatically

❌ **BAD:** Manual connection management

### Health Checks

```python
# ✅ GOOD: Use health check method (returns dict)
health = await db.health_check()

if health["status"] != "healthy":
    logger.error(f"Database unhealthy: {health.get('error')}")

# Check connection status
if db.is_connected():
    await db.test_connection()  # Test with actual query
```

## Async Operations

### Query Execution

```python
# ✅ GOOD: Use async session methods
async with db.session() as session:
    result = await session.execute(
        select(MyModel).where(MyModel.status == "active")
    )
    models = result.scalars().all()
```

❌ **BAD:** Using sync methods

```python
# ❌ BAD: Sync operations (not available in async)
async with db.session() as session:
    models = session.query(MyModel).all()  # Doesn't exist!
```

### Transaction Management

```python
# ✅ GOOD: Use async transaction with session context manager
async with db.session() as session:
    async with session.begin():
        model1 = MyModel(name="Model 1")
        model2 = MyModel(name="Model 2")
        session.add(model1)
        session.add(model2)
        # Committed automatically, or rolled back on error

# ✅ GOOD: Use execute_transaction for callback-based transactions
async def create_models():
    model1 = MyModel(name="Model 1")
    model2 = MyModel(name="Model 2")
    async with db.session() as session:
        session.add(model1)
        session.add(model2)

await db.execute_transaction(create_models)
```

## Error Handling

### Connection Errors

```python
# ✅ GOOD: Handle connection errors
try:
    await db.connect(CONFIG.database_url)
except Exception as e:
    logger.error(f"Failed to connect to database: {e}")
    # Handle error appropriately
```

### Query Errors with Retry Logic

```python
# ✅ GOOD: Use execute_query for automatic retry with exponential backoff
async def fetch_user(session: AsyncSession) -> User:
    result = await session.execute(select(User).where(User.id == 123))
    return result.scalar_one()

user = await db.execute_query(fetch_user, "get_user:123")
# Automatically retries on transient failures (DisconnectionError, OperationalError, TimeoutError)
```

### Query Errors in Controllers

```python
# ✅ GOOD: Let controllers handle query errors
try:
    model = await controller.get(id=123)
except Exception as e:
    logger.error(f"Query failed: {e}")
    # Handle error
```

## Service Lifecycle

### Startup

```python
# ✅ GOOD: Connect on startup
async def startup():
    db = DatabaseService()
    await db.connect(CONFIG.database_url)
    return db
```

### Shutdown

```python
# ✅ GOOD: Disconnect on shutdown
async def shutdown(db: DatabaseService):
    await db.disconnect()  # Disposes engine and clears session factory
```

## Advanced Features

### Schema Validation

```python
# ✅ GOOD: Validate database schema matches models
result = await db.validate_schema()
if result["status"] != "valid":
    logger.error(f"Schema invalid: {result.get('error')}")
    # Run migrations: uv run db reset
```

### Retry Logic with Monitoring

The `execute_query()` method provides:

- **Automatic retry** on transient failures (max 3 attempts)
- **Exponential backoff** (0.5s, 1s, 2s delays)
- **Sentry integration** for performance monitoring
- **Metrics recording** for operation tracking

```python
# ✅ GOOD: Use execute_query for operations that need retry
async def complex_operation(session: AsyncSession) -> Result:
    # Your database operations here
    pass

result = await db.execute_query(complex_operation, "operation_name:context")
```

## Best Practices

1. **Single service instance** - Create one DatabaseService per application
2. **Use context managers** - Always use `async with db.session()`
3. **Let controllers handle sessions** - Don't pass sessions to controllers
4. **Handle errors properly** - Catch and log database errors
5. **Use health checks** - Monitor database connectivity with `health_check()`
6. **Disconnect on shutdown** - Properly disconnect with `disconnect()`
7. **Use execute_query for critical operations** - Automatic retry and monitoring
8. **Validate schema on startup** - Use `validate_schema()` to catch migration issues

## Anti-Patterns

1. ❌ **Multiple service instances** - Use singleton pattern
2. ❌ **Manual session management** - Use context managers
3. ❌ **Passing sessions to controllers** - Controllers manage sessions
4. ❌ **Not handling errors** - Always catch database errors
5. ❌ **Not disconnecting on shutdown** - Use `disconnect()` not `close()`
6. ❌ **Accessing `_session_factory` directly** - Use `session()` method
7. ❌ **Ignoring schema validation** - Validate schema matches models
8. ❌ **Not using retry logic** - Use `execute_query()` for operations that may fail

## See Also

- @database/controllers.mdc - Controller patterns using service
- @database/models.mdc - Model patterns
- @AGENTS.md - General coding standards
- @rules.mdc - Complete catalog of all rules and commands
