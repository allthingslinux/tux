---
description: SQLModel database model patterns, BaseModel usage, relationships, and field definitions for Tux
globs: src/tux/database/models/**/*.py, **/*model*.py
alwaysApply: false
---

# SQLModel Database Models

## Overview

Tux uses SQLModel (SQLAlchemy + Pydantic) for type-safe database models with automatic validation and serialization. All models inherit from `BaseModel` which provides automatic timestamp management.

## Base Model Pattern

All database models must inherit from `BaseModel`:

```python
from tux.database.models import BaseModel

class MyModel(BaseModel, table=True):
    """Model description with NumPy docstring format."""

    id: int = Field(
        primary_key=True,
        sa_type=BigInteger,
        description="Primary key description"
    )
```

✅ **GOOD:** Inherits from BaseModel, includes docstring, proper field definitions

❌ **BAD:** Direct SQLModel inheritance without BaseModel, missing docstrings

```python
# ❌ BAD: Missing BaseModel, no docstring
class MyModel(SQLModel, table=True):
    id: int = Field(primary_key=True)
```

## Field Definitions

### Primary Keys

**Integer IDs (Discord entities):**

```python
id: int = Field(
    primary_key=True,
    sa_type=BigInteger,
    description="Discord guild ID"
)
```

**UUID IDs (internal entities):**

```python
from tux.database.models import UUIDMixin

class MyModel(BaseModel, UUIDMixin, table=True):
    # id is automatically provided by UUIDMixin
    pass
```

✅ **GOOD:** Appropriate ID type for entity type, proper sa_type

❌ **BAD:** Wrong ID type, missing sa_type for BigInteger

### Timestamps

Timestamps are automatically managed by `BaseModel`:

```python
# ✅ GOOD: BaseModel provides created_at and updated_at automatically
class MyModel(BaseModel, table=True):
    name: str

# Timestamps are database-managed:
# - created_at: Set on insert
# - updated_at: Updated on every update
```

❌ **BAD:** Manually defining timestamp fields

```python
# ❌ BAD: Don't manually define timestamps
class MyModel(BaseModel, table=True):
    created_at: datetime = Field(...)  # Already in BaseModel!
```

### Field Types and Constraints

```python
# String fields
name: str = Field(
    max_length=255,
    description="Human-readable name"
)

# Optional fields
description: str | None = Field(
    default=None,
    nullable=True,
    description="Optional description"
)

# Integer with constraints
count: int = Field(
    default=0,
    ge=0,  # Greater than or equal to 0
    description="Non-negative count"
)

# Enum fields
status: CaseType = Field(
    sa_type=PgEnum(CaseType, name="case_type"),
    description="Case type enum"
)

# JSON fields
metadata: dict[str, Any] = Field(
    default_factory=dict,
    sa_type=JSON,
    description="JSON metadata"
)

# DateTime with timezone
created_at: datetime | None = Field(
    sa_type=DateTime(timezone=True),
    description="Creation timestamp"
)
```

✅ **GOOD:** Proper types, constraints, descriptions, nullable handling

❌ **BAD:** Missing constraints, wrong types, no descriptions

## Relationships

### One-to-Many

```python
from sqlalchemy.orm import Mapped, relationship

class Guild(BaseModel, table=True):
    id: int = Field(primary_key=True, sa_type=BigInteger)

    # Relationship definition
    cases: Mapped[list["Case"]] = relationship(
        "Case",
        back_populates="guild",
        cascade="all, delete-orphan"
    )

class Case(BaseModel, table=True):
    guild_id: int = Field(
        foreign_key="guild.id",
        sa_type=BigInteger,
        description="Foreign key to guild"
    )

    guild: Mapped["Guild"] = relationship(
        "Guild",
        back_populates="cases"
    )
```

✅ **GOOD:** Proper Mapped typing, back_populates, cascade options

❌ **BAD:** Missing Mapped, no back_populates, wrong cascade

### Many-to-Many

Use association tables for many-to-many relationships:

```python
class PermissionAssignment(BaseModel, table=True):
    rank_id: UUID = Field(foreign_key="permission_rank.id")
    command_id: UUID = Field(foreign_key="permission_command.id")

    # Composite primary key
    __table_args__ = (
        UniqueConstraint("rank_id", "command_id"),
    )
```

## Model Organization

### File Structure

```text
src/tux/database/models/
├── __init__.py          # Exports all models
├── base.py              # BaseModel, mixins
├── enums.py             # Database enums
└── models.py            # All model definitions
```

### Import Pattern

```python
# ✅ GOOD: Import from models package
from tux.database.models import Guild, Case, BaseModel

# ❌ BAD: Direct imports from files
from tux.database.models.models import Guild
```

## Validation and Serialization

### Pydantic Validation

SQLModel models automatically validate on creation:

```python
# ✅ GOOD: Validation happens automatically
guild = Guild(id=123456789, case_count=0)

# ❌ BAD: Invalid data raises ValidationError
guild = Guild(id=-1)  # Fails if ge=0 constraint exists
```

### Serialization

Use `to_dict()` method from BaseModel:

```python
# ✅ GOOD: Use built-in serialization
guild_dict = guild.to_dict()
guild_dict_with_rels = guild.to_dict(include_relationships=True)

# ❌ BAD: Manual dict conversion
guild_dict = {"id": guild.id, "name": guild.name}  # Misses timestamps
```

## Best Practices

1. **Always inherit from BaseModel** for automatic timestamps
2. **Use appropriate ID types**: BigInteger for Discord IDs, UUID for internal
3. **Add constraints**: Use `ge`, `le`, `max_length` where appropriate
4. **Document fields**: Include description in Field() definitions
5. **Use Mapped[] for relationships**: Type-safe relationship definitions
6. **Validate with Pydantic**: Let SQLModel handle validation
7. **Use to_dict() for serialization**: Don't manually convert to dict

## Anti-Patterns

1. ❌ **Direct SQLModel inheritance** - Always use BaseModel
2. ❌ **Manual timestamp fields** - BaseModel provides them
3. ❌ **Missing field descriptions** - Always document fields
4. ❌ **Wrong ID types** - Use BigInteger for Discord IDs
5. ❌ **Missing constraints** - Add validation constraints
6. ❌ **Manual serialization** - Use to_dict() method

## See Also

- @database/migrations.mdc - Migration patterns
- @database/controllers.mdc - Controller patterns
- @database/services.mdc - Service layer patterns
- @AGENTS.md - General coding standards
- @rules.mdc - Complete catalog of all rules and commands
